{
  "metadata": {
    "timestamp": "2026-02-15T11:29:26.032365",
    "num_models": 4,
    "num_queries": 18,
    "models": {
      "qwen2.5-coder-32b": "Qwen/Qwen2.5-Coder-32B-Instruct",
      "llama-3.1-8b": "meta-llama/Llama-3.1-8B-Instruct",
      "mistral-7b": "mistralai/Mistral-7B-Instruct-v0.2",
      "qwen2.5-coder-7b": "Qwen/Qwen2.5-Coder-7B-Instruct"
    }
  },
  "summary": {
    "qwen2.5-coder-32b": {
      "total": 18,
      "execution_success": 17,
      "execution_rate": 94.4,
      "row_count_match": 16,
      "row_count_rate": 88.9,
      "exact_match": 8,
      "exact_match_rate": 44.4,
      "fuzzy_match": 8,
      "result_match": 8,
      "accuracy": 44.4,
      "avg_row_overlap_pct": 47.1,
      "by_concept": {
        "basic": {
          "total": 3,
          "execution_success": 3,
          "exact_match": 2,
          "fuzzy_match": 2,
          "result_match": 2
        },
        "intermediate": {
          "total": 3,
          "execution_success": 3,
          "exact_match": 2,
          "fuzzy_match": 2,
          "result_match": 2
        },
        "window_function": {
          "total": 4,
          "execution_success": 4,
          "exact_match": 3,
          "fuzzy_match": 3,
          "result_match": 3
        },
        "cte": {
          "total": 4,
          "execution_success": 3,
          "exact_match": 1,
          "fuzzy_match": 1,
          "result_match": 1
        },
        "complex_combination": {
          "total": 4,
          "execution_success": 4,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        }
      },
      "failure_modes": {
        "wrong_values": 8,
        "execution_error": 1,
        "wrong_row_count": 1
      }
    },
    "llama-3.1-8b": {
      "total": 18,
      "execution_success": 8,
      "execution_rate": 44.4,
      "row_count_match": 8,
      "row_count_rate": 44.4,
      "exact_match": 1,
      "exact_match_rate": 5.6,
      "fuzzy_match": 1,
      "result_match": 1,
      "accuracy": 5.6,
      "avg_row_overlap_pct": 12.5,
      "by_concept": {
        "basic": {
          "total": 3,
          "execution_success": 2,
          "exact_match": 1,
          "fuzzy_match": 1,
          "result_match": 1
        },
        "intermediate": {
          "total": 3,
          "execution_success": 2,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        },
        "window_function": {
          "total": 4,
          "execution_success": 2,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        },
        "cte": {
          "total": 4,
          "execution_success": 2,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        },
        "complex_combination": {
          "total": 4,
          "execution_success": 0,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        }
      },
      "failure_modes": {
        "wrong_values": 7,
        "execution_error": 10
      }
    },
    "mistral-7b": {
      "total": 18,
      "execution_success": 16,
      "execution_rate": 88.9,
      "row_count_match": 12,
      "row_count_rate": 66.7,
      "exact_match": 5,
      "exact_match_rate": 27.8,
      "fuzzy_match": 5,
      "result_match": 5,
      "accuracy": 27.8,
      "avg_row_overlap_pct": 37.5,
      "by_concept": {
        "basic": {
          "total": 3,
          "execution_success": 3,
          "exact_match": 2,
          "fuzzy_match": 2,
          "result_match": 2
        },
        "intermediate": {
          "total": 3,
          "execution_success": 3,
          "exact_match": 2,
          "fuzzy_match": 2,
          "result_match": 2
        },
        "window_function": {
          "total": 4,
          "execution_success": 4,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        },
        "cte": {
          "total": 4,
          "execution_success": 3,
          "exact_match": 1,
          "fuzzy_match": 1,
          "result_match": 1
        },
        "complex_combination": {
          "total": 4,
          "execution_success": 3,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        }
      },
      "failure_modes": {
        "wrong_values": 7,
        "wrong_row_count": 4,
        "execution_error": 2
      }
    },
    "qwen2.5-coder-7b": {
      "total": 18,
      "execution_success": 16,
      "execution_rate": 88.9,
      "row_count_match": 13,
      "row_count_rate": 72.2,
      "exact_match": 4,
      "exact_match_rate": 22.2,
      "fuzzy_match": 4,
      "result_match": 4,
      "accuracy": 22.2,
      "avg_row_overlap_pct": 27.2,
      "by_concept": {
        "basic": {
          "total": 3,
          "execution_success": 3,
          "exact_match": 2,
          "fuzzy_match": 2,
          "result_match": 2
        },
        "intermediate": {
          "total": 3,
          "execution_success": 3,
          "exact_match": 1,
          "fuzzy_match": 1,
          "result_match": 1
        },
        "window_function": {
          "total": 4,
          "execution_success": 3,
          "exact_match": 1,
          "fuzzy_match": 1,
          "result_match": 1
        },
        "cte": {
          "total": 4,
          "execution_success": 4,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        },
        "complex_combination": {
          "total": 4,
          "execution_success": 3,
          "exact_match": 0,
          "fuzzy_match": 0,
          "result_match": 0
        }
      },
      "failure_modes": {
        "wrong_values": 9,
        "execution_error": 2,
        "wrong_row_count": 3
      }
    }
  },
  "results": [
    {
      "query_id": "ba01",
      "concept_tag": "basic",
      "nl_question": "List all customers from Brazil.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT FirstName || ' ' || LastName AS FullName FROM CUSTOMER WHERE Country = 'Brazil'",
      "raw_output": "SELECT FirstName || ' ' || LastName AS FullName FROM CUSTOMER WHERE Country = 'Brazil'",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 2.02
    },
    {
      "query_id": "ba02",
      "concept_tag": "basic",
      "nl_question": "How many tracks are in each genre? Show the genre name and count, ordered by count descending.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT T2.Name, COUNT(*) AS TrackCount FROM TRACK AS T1 INNER JOIN GENRE AS T2 ON T1.GenreId = T2.GenreId GROUP BY T2.Name ORDER BY TrackCount DESC",
      "raw_output": "SELECT T2.Name, COUNT(*) AS TrackCount FROM TRACK AS T1 INNER JOIN GENRE AS T2 ON T1.GenreId = T2.GenreId GROUP BY T2.Name ORDER BY TrackCount DESC",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 25,
      "gen_row_count": 25,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.66
    },
    {
      "query_id": "ba03",
      "concept_tag": "basic",
      "nl_question": "Find the total number of invoices and the overall sum of invoice totals.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT COUNT(*) ,  SUM(Total) FROM INVOICE",
      "raw_output": "SELECT COUNT(*) ,  SUM(Total) FROM INVOICE",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 1,
      "gen_row_count": 1,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.17
    },
    {
      "query_id": "in01",
      "concept_tag": "intermediate",
      "nl_question": "Find all albums that have more than 20 tracks.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT Title FROM ALBUM WHERE AlbumId IN (SELECT AlbumId FROM TRACK GROUP BY AlbumId HAVING COUNT(*) > 20)",
      "raw_output": "SELECT Title FROM ALBUM WHERE AlbumId IN (SELECT AlbumId FROM TRACK GROUP BY AlbumId HAVING COUNT(*) > 20)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 17,
      "gen_row_count": 17,
      "missing_count": 17,
      "extra_count": 17,
      "latency_s": 1.16
    },
    {
      "query_id": "in02",
      "concept_tag": "intermediate",
      "nl_question": "Which customers have placed more than 5 invoices? Show their name and invoice count.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT c.FirstName || ' ' || c.LastName AS CustomerName, COUNT(i.InvoiceId) AS InvoiceCount\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY c.CustomerId\nHAVING InvoiceCount > 5",
      "raw_output": "SELECT c.FirstName || ' ' || c.LastName AS CustomerName, COUNT(i.InvoiceId) AS InvoiceCount\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY c.CustomerId\nHAVING InvoiceCount > 5",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 59,
      "gen_row_count": 59,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.77
    },
    {
      "query_id": "in03",
      "concept_tag": "intermediate",
      "nl_question": "Find the top 10 most purchased tracks, showing the track name, artist, and number of times purchased.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT T2.Name, A.Title, COUNT(*) AS PurchaseCount\nFROM InvoiceLine IL\nJOIN Track T2 ON IL.TrackId = T2.TrackId\nJOIN Album A ON T2.AlbumId = A.AlbumId\nGROUP BY T2.Name, A.Title\nORDER BY PurchaseCount DESC\nLIMIT 10",
      "raw_output": "SELECT T2.Name, A.Title, COUNT(*) AS PurchaseCount\nFROM InvoiceLine IL\nJOIN Track T2 ON IL.TrackId = T2.TrackId\nJOIN Album A ON T2.AlbumId = A.AlbumId\nGROUP BY T2.Name, A.Title\nORDER BY PurchaseCount DESC\nLIMIT 10",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 10,
      "gen_row_count": 10,
      "missing_count": 10,
      "extra_count": 10,
      "latency_s": 1.74
    },
    {
      "query_id": "wf01",
      "concept_tag": "window_function",
      "nl_question": "For each genre, rank the tracks by unit price descending and show the top 3 most expensive tracks per genre.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT g.Name AS Genre, t.Name AS Track, t.UnitPrice AS Price, RANK() OVER (PARTITION BY g.GenreId ORDER BY t.UnitPrice DESC) AS Rank\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nWHERE RANK() OVER (PARTITION BY g.GenreId ORDER BY t.UnitPrice DESC) <= 3",
      "raw_output": "SELECT g.Name AS Genre, t.Name AS Track, t.UnitPrice AS Price, RANK() OVER (PARTITION BY g.GenreId ORDER BY t.UnitPrice DESC) AS Rank\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nWHERE RANK() OVER (PARTITION BY g.GenreId ORDER BY t.UnitPrice DESC) <= 3",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "misuse of window function RANK()",
      "latency_s": 2.16
    },
    {
      "query_id": "wf02",
      "concept_tag": "window_function",
      "nl_question": "Show each employee's total sales alongside the running total of sales across all employees ordered by total sales descending.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT e.FirstName || ' ' || e.LastName AS EmployeeName, SUM(il.UnitPrice * il.Quantity) AS TotalSales, (\n    SELECT SUM(il2.UnitPrice * il2.Quantity)\n    FROM Invoice i2\n    JOIN InvoiceLine il2 ON i2.InvoiceId = il2.InvoiceId\n) AS RunningTotalSales\nFROM Employee e\nJOIN Customer c ON e.EmployeeId = c.SupportRepId\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY e.EmployeeId\nORDER BY TotalSales DESC",
      "raw_output": "SELECT e.FirstName || ' ' || e.LastName AS EmployeeName, SUM(il.UnitPrice * il.Quantity) AS TotalSales, (\n    SELECT SUM(il2.UnitPrice * il2.Quantity)\n    FROM Invoice i2\n    JOIN InvoiceLine il2 ON i2.InvoiceId = il2.InvoiceId\n) AS RunningTotalSales\nFROM Employee e\nJOIN Customer c ON e.EmployeeId = c.SupportRepId\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY e.EmployeeId\nORDER BY TotalSales DESC",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 33.3,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 3,
      "gen_row_count": 3,
      "missing_count": 2,
      "extra_count": 2,
      "latency_s": 2.49
    },
    {
      "query_id": "wf03",
      "concept_tag": "window_function",
      "nl_question": "For each customer, show their invoice totals and the percentage each invoice contributes to their overall spending.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT c.FirstName || ' ' || c.LastName AS CustomerName, i.InvoiceId, i.Total, ROUND((i.Total / SUM(i.Total) OVER (PARTITION BY c.CustomerId)) * 100, 2) AS PercentageOfSpending\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId",
      "raw_output": "SELECT c.FirstName || ' ' || c.LastName AS CustomerName, i.InvoiceId, i.Total, ROUND((i.Total / SUM(i.Total) OVER (PARTITION BY c.CustomerId)) * 100, 2) AS PercentageOfSpending\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 412,
      "gen_row_count": 412,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 2.0
    },
    {
      "query_id": "wf04",
      "concept_tag": "window_function",
      "nl_question": "Show the month-over-month change in total invoice amounts for each year-month combination.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT \n    strftime('%Y-%m', InvoiceDate) AS YearMonth,\n    SUM(Total) AS TotalAmount,\n    LAG(SUM(Total), 1) OVER (PARTITION BY strftime('%Y', InvoiceDate) ORDER BY strftime('%m', InvoiceDate)) AS PreviousMonthAmount\nFROM \n    Invoice\nGROUP BY \n    strftime('%Y-%m', InvoiceDate)\nORDER BY \n    YearMonth",
      "raw_output": "SELECT \n    strftime('%Y-%m', InvoiceDate) AS YearMonth,\n    SUM(Total) AS TotalAmount,\n    LAG(SUM(Total), 1) OVER (PARTITION BY strftime('%Y', InvoiceDate) ORDER BY strftime('%m', InvoiceDate)) AS PreviousMonthAmount\nFROM \n    Invoice\nGROUP BY \n    strftime('%Y-%m', InvoiceDate)\nORDER BY \n    YearMonth;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 1.7,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 60,
      "gen_row_count": 60,
      "missing_count": 59,
      "extra_count": 59,
      "latency_s": 1.98
    },
    {
      "query_id": "cte01",
      "concept_tag": "cte",
      "nl_question": "Find customers who have spent more than the average customer lifetime value.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT c.FirstName || ' ' || c.LastName AS FullName, SUM(il.UnitPrice * il.Quantity) AS TotalSpent\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.CustomerId\nHAVING TotalSpent > (\n    SELECT AVG(TotalSpent)\n    FROM (\n        SELECT SUM(il.UnitPrice * il.Quantity) AS TotalSpent\n        FROM Customer c\n        JOIN Invoice i ON c.CustomerId = i.CustomerId\n        JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\n        GROUP BY c.CustomerId\n    )\n)",
      "raw_output": "SELECT c.FirstName || ' ' || c.LastName AS FullName, SUM(il.UnitPrice * il.Quantity) AS TotalSpent\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.CustomerId\nHAVING TotalSpent > (\n    SELECT AVG(TotalSpent)\n    FROM (\n        SELECT SUM(il.UnitPrice * il.Quantity) AS TotalSpent\n        FROM Customer c\n        JOIN Invoice i ON c.CustomerId = i.CustomerId\n        JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\n        GROUP BY c.CustomerId\n    )\n)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 22,
      "gen_row_count": 22,
      "missing_count": 22,
      "extra_count": 22,
      "latency_s": 2.97
    },
    {
      "query_id": "cte02",
      "concept_tag": "cte",
      "nl_question": "Find the top 5 artists by number of tracks sold, along with their total revenue.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT Artist.Name, SUM(InvoiceLine.UnitPrice * InvoiceLine.Quantity) AS TotalRevenue\nFROM Artist\nJOIN Album ON Artist.ArtistId = Album.ArtistId\nJOIN Track ON Album.AlbumId = Track.AlbumId\nJOIN InvoiceLine ON Track.TrackId = InvoiceLine.TrackId\nGROUP BY Artist.Name\nORDER BY COUNT(InvoiceLine.InvoiceLineId) DESC, TotalRevenue DESC\nLIMIT 5",
      "raw_output": "SELECT Artist.Name, SUM(InvoiceLine.UnitPrice * InvoiceLine.Quantity) AS TotalRevenue\nFROM Artist\nJOIN Album ON Artist.ArtistId = Album.ArtistId\nJOIN Track ON Album.AlbumId = Track.AlbumId\nJOIN InvoiceLine ON Track.TrackId = InvoiceLine.TrackId\nGROUP BY Artist.Name\nORDER BY COUNT(InvoiceLine.InvoiceLineId) DESC, TotalRevenue DESC\nLIMIT 5",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 2.35
    },
    {
      "query_id": "cte03",
      "concept_tag": "cte",
      "nl_question": "For each country, show the number of customers, total revenue, and average revenue per customer.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT c.Country, COUNT(c.CustomerId) AS NumberOfCustomers, SUM(il.UnitPrice * il.Quantity) AS TotalRevenue, AVG(SUM(il.UnitPrice * il.Quantity)) OVER (PARTITION BY c.Country) AS AverageRevenuePerCustomer\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.Country",
      "raw_output": "SELECT c.Country, COUNT(c.CustomerId) AS NumberOfCustomers, SUM(il.UnitPrice * il.Quantity) AS TotalRevenue, AVG(SUM(il.UnitPrice * il.Quantity)) OVER (PARTITION BY c.Country) AS AverageRevenuePerCustomer\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.Country;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 24,
      "gen_row_count": 24,
      "missing_count": 24,
      "extra_count": 24,
      "latency_s": 2.09
    },
    {
      "query_id": "cte04",
      "concept_tag": "cte",
      "nl_question": "Find all genres where the average track length is longer than the overall average track length across all genres.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT g.Name\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nGROUP BY g.Name\nHAVING AVG(t.Milliseconds) > (\n    SELECT AVG(Milliseconds)\n    FROM Track\n)",
      "raw_output": "SELECT g.Name\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nGROUP BY g.Name\nHAVING AVG(t.Milliseconds) > (\n    SELECT AVG(Milliseconds)\n    FROM Track\n);",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 1.68
    },
    {
      "query_id": "cx01",
      "concept_tag": "complex_combination",
      "nl_question": "Rank customers by their total spending within each country, and show only the top 2 customers per country.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT c.Country, c.FirstName || ' ' || c.LastName AS FullName, SUM(il.UnitPrice * il.Quantity) AS TotalSpending\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.Country, c.CustomerId\nORDER BY c.Country, TotalSpending DESC\nLIMIT 2",
      "raw_output": "SELECT c.Country, c.FirstName || ' ' || c.LastName AS FullName, SUM(il.UnitPrice * il.Quantity) AS TotalSpending\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.Country, c.CustomerId\nORDER BY c.Country, TotalSpending DESC\nLIMIT 2",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 33,
      "gen_row_count": 2,
      "missing_count": 33,
      "extra_count": 2,
      "latency_s": 2.13
    },
    {
      "query_id": "cx02",
      "concept_tag": "complex_combination",
      "nl_question": "Show each artist's share of total tracks in the database, but only for artists with more than 20 tracks.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT Artist.Name, ROUND(CAST(SUM(CASE WHEN COUNT(*) > 20 THEN 1 ELSE 0 END) AS REAL) / COUNT(*), 2) AS ShareOfTracks\nFROM Artist\nJOIN Album ON Artist.ArtistId = Album.ArtistId\nJOIN Track ON Album.AlbumId = Track.AlbumId\nGROUP BY Artist.Name\nHAVING COUNT(*) > 20",
      "raw_output": "SELECT Artist.Name, ROUND(CAST(SUM(CASE WHEN COUNT(*) > 20 THEN 1 ELSE 0 END) AS REAL) / COUNT(*), 2) AS ShareOfTracks\nFROM Artist\nJOIN Album ON Artist.ArtistId = Album.ArtistId\nJOIN Track ON Album.AlbumId = Track.AlbumId\nGROUP BY Artist.Name\nHAVING COUNT(*) > 20",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "misuse of aggregate function COUNT()",
      "latency_s": 2.19
    },
    {
      "query_id": "cx03",
      "concept_tag": "complex_combination",
      "nl_question": "Find the quarter with the highest revenue for each year in the database.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT \n    STRFTIME('%Y', i.InvoiceDate) AS Year,\n    STRFTIME('%m', i.InvoiceDate) AS Month,\n    SUM(il.UnitPrice * il.Quantity) AS Revenue\nFROM \n    Invoice i\nJOIN \n    InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY \n    STRFTIME('%Y', i.InvoiceDate), \n    STRFTIME('%m', i.InvoiceDate)\nORDER BY \n    Year, \n    Month",
      "raw_output": "SELECT \n    STRFTIME('%Y', i.InvoiceDate) AS Year,\n    STRFTIME('%m', i.InvoiceDate) AS Month,\n    SUM(il.UnitPrice * il.Quantity) AS Revenue\nFROM \n    Invoice i\nJOIN \n    InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY \n    STRFTIME('%Y', i.InvoiceDate), \n    STRFTIME('%m', i.InvoiceDate)\nORDER BY \n    Year, \n    Month;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 5,
      "gen_row_count": 60,
      "missing_count": 5,
      "extra_count": 60,
      "latency_s": 2.44
    },
    {
      "query_id": "cx04",
      "concept_tag": "complex_combination",
      "nl_question": "Show a playlist diversity score: for each playlist, count the number of distinct genres and distinct artists it contains.",
      "model": "qwen2.5-coder-7b",
      "generated_sql": "SELECT p.PlaylistId, COUNT(DISTINCT t.GenreId) AS GenreDiversity, COUNT(DISTINCT a.ArtistId) AS ArtistDiversity \nFROM Playlist p \nJOIN PlaylistTrack pt ON p.PlaylistId = pt.PlaylistId \nJOIN Track t ON pt.TrackId = t.TrackId \nJOIN Album a ON t.AlbumId = a.AlbumId \nGROUP BY p.PlaylistId",
      "raw_output": "SELECT p.PlaylistId, COUNT(DISTINCT t.GenreId) AS GenreDiversity, COUNT(DISTINCT a.ArtistId) AS ArtistDiversity \nFROM Playlist p \nJOIN PlaylistTrack pt ON p.PlaylistId = pt.PlaylistId \nJOIN Track t ON pt.TrackId = t.TrackId \nJOIN Album a ON t.AlbumId = a.AlbumId \nGROUP BY p.PlaylistId",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 12,
      "gen_row_count": 14,
      "missing_count": 12,
      "extra_count": 14,
      "latency_s": 2.21
    },
    {
      "query_id": "ba01",
      "concept_tag": "basic",
      "nl_question": "List all customers from Brazil.",
      "model": "mistral-7b",
      "generated_sql": "SELECT FirstName || ' ' || LastName AS \"Customer Name\", CustomerId, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email FROM Customer WHERE Country = 'Brazil'",
      "raw_output": "SELECT FirstName || ' ' || LastName AS \"Customer Name\", CustomerId, Company, Address, City, State, Country, PostalCode, Phone, Fax, Email FROM Customer WHERE Country = 'Brazil';",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 0.79
    },
    {
      "query_id": "ba02",
      "concept_tag": "basic",
      "nl_question": "How many tracks are in each genre? Show the genre name and count, ordered by count descending.",
      "model": "mistral-7b",
      "generated_sql": "SELECT Genre.Name AS GenreName, COUNT(Track.TrackId) AS TrackCount\nFROM Genre\nLEFT JOIN Track ON Genre.GenreId = Track.GenreId\nGROUP BY Genre.GenreId, Genre.Name\nORDER BY TrackCount DESC",
      "raw_output": "SELECT Genre.Name AS GenreName, COUNT(Track.TrackId) AS TrackCount\nFROM Genre\nLEFT JOIN Track ON Genre.GenreId = Track.GenreId\nGROUP BY Genre.GenreId, Genre.Name\nORDER BY TrackCount DESC;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 25,
      "gen_row_count": 25,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.87
    },
    {
      "query_id": "ba03",
      "concept_tag": "basic",
      "nl_question": "Find the total number of invoices and the overall sum of invoice totals.",
      "model": "mistral-7b",
      "generated_sql": "SELECT COUNT(*) AS total_invoices, ROUND(SUM(Total), 2) AS overall_sum FROM Invoice",
      "raw_output": "SELECT COUNT(*) AS total_invoices, ROUND(SUM(Total), 2) AS overall_sum FROM Invoice;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 1,
      "gen_row_count": 1,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.47
    },
    {
      "query_id": "in01",
      "concept_tag": "intermediate",
      "nl_question": "Find all albums that have more than 20 tracks.",
      "model": "mistral-7b",
      "generated_sql": "SELECT AlbumId, Title, ArtistId FROM Album WHERE AlbumId IN (SELECT AlbumId FROM Track GROUP BY AlbumId HAVING COUNT(*) > 20)",
      "raw_output": "SELECT AlbumId, Title, ArtistId FROM Album WHERE AlbumId IN (SELECT AlbumId FROM Track GROUP BY AlbumId HAVING COUNT(*) > 20);",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 17,
      "gen_row_count": 17,
      "missing_count": 17,
      "extra_count": 17,
      "latency_s": 0.57
    },
    {
      "query_id": "in02",
      "concept_tag": "intermediate",
      "nl_question": "Which customers have placed more than 5 invoices? Show their name and invoice count.",
      "model": "mistral-7b",
      "generated_sql": "SELECT FirstName || ' ' || LastName AS CustomerName, COUNT(*) AS InvoiceCount\nFROM Customer\nJOIN Invoice ON Customer.CustomerId = Invoice.CustomerId\nGROUP BY Customer.CustomerId\nHAVING COUNT(*) > 5",
      "raw_output": "SELECT FirstName || ' ' || LastName AS CustomerName, COUNT(*) AS InvoiceCount\nFROM Customer\nJOIN Invoice ON Customer.CustomerId = Invoice.CustomerId\nGROUP BY Customer.CustomerId\nHAVING COUNT(*) > 5;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 59,
      "gen_row_count": 59,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.72
    },
    {
      "query_id": "in03",
      "concept_tag": "intermediate",
      "nl_question": "Find the top 10 most purchased tracks, showing the track name, artist, and number of times purchased.",
      "model": "mistral-7b",
      "generated_sql": "SELECT t.Name AS TrackName, a.Name AS Artist, COUNT(*) AS TimesPurchased\nFROM Track t\nJOIN Album al ON t.AlbumId = al.AlbumId\nJOIN Artist a ON al.ArtistId = a.ArtistId\nJOIN InvoiceLine il ON t.TrackId = il.TrackId\nGROUP BY t.TrackId, t.Name, a.Name\nORDER BY TimesPurchased DESC\nLIMIT 10",
      "raw_output": "SELECT t.Name AS TrackName, a.Name AS Artist, COUNT(*) AS TimesPurchased\nFROM Track t\nJOIN Album al ON t.AlbumId = al.AlbumId\nJOIN Artist a ON al.ArtistId = a.ArtistId\nJOIN InvoiceLine il ON t.TrackId = il.TrackId\nGROUP BY t.TrackId, t.Name, a.Name\nORDER BY TimesPurchased DESC\nLIMIT 10;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 10,
      "gen_row_count": 10,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.85
    },
    {
      "query_id": "wf01",
      "concept_tag": "window_function",
      "nl_question": "For each genre, rank the tracks by unit price descending and show the top 3 most expensive tracks per genre.",
      "model": "mistral-7b",
      "generated_sql": "WITH RankedTracks AS (\n    SELECT\n        g.Name AS GenreName,\n        t.TrackId,\n        t.Name AS TrackName,\n        t.UnitPrice,\n        ROW_NUMBER() OVER (PARTITION BY g.Name ORDER BY t.UnitPrice DESC) AS rn\n    FROM\n        Track t\n    JOIN\n        Genre g ON t.GenreId = g.GenreId\n)\nSELECT\n    GenreName,\n    TrackId,\n    TrackName,\n    UnitPrice\nFROM\n    RankedTracks\nWHERE\n    rn <= 3\nORDER BY\n    GenreName,\n    UnitPrice DESC",
      "raw_output": "WITH RankedTracks AS (\n    SELECT\n        g.Name AS GenreName,\n        t.TrackId,\n        t.Name AS TrackName,\n        t.UnitPrice,\n        ROW_NUMBER() OVER (PARTITION BY g.Name ORDER BY t.UnitPrice DESC) AS rn\n    FROM\n        Track t\n    JOIN\n        Genre g ON t.GenreId = g.GenreId\n)\nSELECT\n    GenreName,\n    TrackId,\n    TrackName,\n    UnitPrice\nFROM\n    RankedTracks\nWHERE\n    rn <= 3\nORDER BY\n    GenreName,\n    UnitPrice DESC;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 73,
      "gen_row_count": 73,
      "missing_count": 73,
      "extra_count": 73,
      "latency_s": 2.19
    },
    {
      "query_id": "wf02",
      "concept_tag": "window_function",
      "nl_question": "Show each employee's total sales alongside the running total of sales across all employees ordered by total sales descending.",
      "model": "mistral-7b",
      "generated_sql": "WITH EmployeeSales AS (\n    SELECT\n        e.EmployeeId,\n        e.FirstName || ' ' || e.LastName AS EmployeeName,\n        ROUND(SUM(i.Total), 2) AS TotalSales\n    FROM\n        Employee e\n    LEFT JOIN\n        Customer c ON e.EmployeeId = c.SupportRepId\n    LEFT JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        e.EmployeeId, e.FirstName, e.LastName\n),\nRankedSales AS (\n    SELECT\n        *,\n        ROW_NUMBER() OVER (ORDER BY TotalSales DESC) AS rk\n    FROM\n        EmployeeSales\n)\nSELECT\n    EmployeeName,\n    TotalSales,\n    (SELECT ROUND(SUM(TotalSales), 2)\n     FROM RankedSales\n     WHERE rk <= rs.rk) AS RunningTotal\nFROM\n    RankedSales rs\nORDER BY\n    TotalSales DESC",
      "raw_output": "WITH EmployeeSales AS (\n    SELECT\n        e.EmployeeId,\n        e.FirstName || ' ' || e.LastName AS EmployeeName,\n        ROUND(SUM(i.Total), 2) AS TotalSales\n    FROM\n        Employee e\n    LEFT JOIN\n        Customer c ON e.EmployeeId = c.SupportRepId\n    LEFT JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        e.EmployeeId, e.FirstName, e.LastName\n),\nRankedSales AS (\n    SELECT\n        *,\n        ROW_NUMBER() OVER (ORDER BY TotalSales DESC) AS rk\n    FROM\n        EmployeeSales\n)\nSELECT\n    EmployeeName,\n    TotalSales,\n    (SELECT ROUND(SUM(TotalSales), 2)\n     FROM RankedSales\n     WHERE rk <= rs.rk) AS RunningTotal\nFROM\n    RankedSales rs\nORDER BY\n    TotalSales DESC;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 100.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 3,
      "gen_row_count": 8,
      "missing_count": 0,
      "extra_count": 5,
      "latency_s": 2.38
    },
    {
      "query_id": "wf03",
      "concept_tag": "window_function",
      "nl_question": "For each customer, show their invoice totals and the percentage each invoice contributes to their overall spending.",
      "model": "mistral-7b",
      "generated_sql": "WITH CustomerTotals AS (\n    SELECT\n        c.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        SUM(i.Total) AS TotalSpending\n    FROM\n        Customer c\n    JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        c.CustomerId\n),\nInvoicePercentages AS (\n    SELECT\n        i.InvoiceId,\n        i.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        i.InvoiceDate,\n        i.Total AS InvoiceTotal,\n        ct.TotalSpending AS CustomerTotalSpending,\n        ROUND((i.Total / ct.TotalSpending) * 100, 2) AS InvoicePercentage\n    FROM\n        Invoice i\n    JOIN\n        Customer c ON i.CustomerId = c.CustomerId\n    JOIN\n        CustomerTotals ct ON c.CustomerId = ct.CustomerId\n)\nSELECT\n    CustomerName,\n    InvoiceId,\n    InvoiceDate,\n    InvoiceTotal,\n    InvoicePercentage\nFROM\n    InvoicePercentages\nORDER BY\n    CustomerName,\n    InvoiceDate",
      "raw_output": "```sql\nWITH CustomerTotals AS (\n    SELECT\n        c.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        SUM(i.Total) AS TotalSpending\n    FROM\n        Customer c\n    JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        c.CustomerId\n),\nInvoicePercentages AS (\n    SELECT\n        i.InvoiceId,\n        i.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        i.InvoiceDate,\n        i.Total AS InvoiceTotal,\n        ct.TotalSpending AS CustomerTotalSpending,\n        ROUND((i.Total / ct.TotalSpending) * 100, 2) AS InvoicePercentage\n    FROM\n        Invoice i\n    JOIN\n        Customer c ON i.CustomerId = c.CustomerId\n    JOIN\n        CustomerTotals ct ON c.CustomerId = ct.CustomerId\n)\nSELECT\n    CustomerName,\n    InvoiceId,\n    InvoiceDate,\n    InvoiceTotal,\n    InvoicePercentage\nFROM\n    InvoicePercentages\nORDER BY\n    CustomerName,\n    InvoiceDate;\n```",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 412,
      "gen_row_count": 412,
      "missing_count": 412,
      "extra_count": 412,
      "latency_s": 2.82
    },
    {
      "query_id": "wf04",
      "concept_tag": "window_function",
      "nl_question": "Show the month-over-month change in total invoice amounts for each year-month combination.",
      "model": "mistral-7b",
      "generated_sql": "WITH MonthlyTotals AS (\n    SELECT\n        strftime('%Y-%m', InvoiceDate) AS year_month,\n        SUM(Total) AS total_amount\n    FROM Invoice\n    GROUP BY year_month\n),\nMonthlyChanges AS (\n    SELECT\n        year_month,\n        total_amount,\n        LAG(total_amount) OVER (ORDER BY strftime('%Y', year_month), strftime('%m', year_month)) AS previous_month_amount\n    FROM MonthlyTotals\n)\nSELECT\n    year_month,\n    total_amount,\n    ROUND((total_amount - previous_month_amount) * 100.0 / NULLIF(previous_month_amount, 0), 2) AS month_over_month_change_percentage,\n    ROUND(total_amount - previous_month_amount, 2) AS month_over_month_change_amount\nFROM MonthlyChanges\nORDER BY year_month",
      "raw_output": "WITH MonthlyTotals AS (\n    SELECT\n        strftime('%Y-%m', InvoiceDate) AS year_month,\n        SUM(Total) AS total_amount\n    FROM Invoice\n    GROUP BY year_month\n),\nMonthlyChanges AS (\n    SELECT\n        year_month,\n        total_amount,\n        LAG(total_amount) OVER (ORDER BY strftime('%Y', year_month), strftime('%m', year_month)) AS previous_month_amount\n    FROM MonthlyTotals\n)\nSELECT\n    year_month,\n    total_amount,\n    ROUND((total_amount - previous_month_amount) * 100.0 / NULLIF(previous_month_amount, 0), 2) AS month_over_month_change_percentage,\n    ROUND(total_amount - previous_month_amount, 2) AS month_over_month_change_amount\nFROM MonthlyChanges\nORDER BY year_month;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 60,
      "gen_row_count": 60,
      "missing_count": 60,
      "extra_count": 60,
      "latency_s": 2.72
    },
    {
      "query_id": "cte01",
      "concept_tag": "cte",
      "nl_question": "Find customers who have spent more than the average customer lifetime value.",
      "model": "mistral-7b",
      "generated_sql": "WITH CustomerLifetimeValue AS (\n    SELECT\n        c.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        SUM(i.Total) AS TotalSpent\n    FROM\n        Customer c\n    LEFT JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        c.CustomerId\n)\nSELECT\n    CustomerId,\n    CustomerName,\n    ROUND(TotalSpent, 2) AS CustomerLifetimeValue\nFROM\n    CustomerLifetimeValue\nWHERE\n    TotalSpent > (SELECT AVG(TotalSpent) FROM CustomerLifetimeValue)",
      "raw_output": "WITH CustomerLifetimeValue AS (\n    SELECT\n        c.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        SUM(i.Total) AS TotalSpent\n    FROM\n        Customer c\n    LEFT JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        c.CustomerId\n)\nSELECT\n    CustomerId,\n    CustomerName,\n    ROUND(TotalSpent, 2) AS CustomerLifetimeValue\nFROM\n    CustomerLifetimeValue\nWHERE\n    TotalSpent > (SELECT AVG(TotalSpent) FROM CustomerLifetimeValue)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 22,
      "gen_row_count": 22,
      "missing_count": 22,
      "extra_count": 22,
      "latency_s": 1.66
    },
    {
      "query_id": "cte02",
      "concept_tag": "cte",
      "nl_question": "Find the top 5 artists by number of tracks sold, along with their total revenue.",
      "model": "mistral-7b",
      "generated_sql": "SELECT Artist.Name AS ArtistName, COUNT(*) AS TotalTracksSold, ROUND(SUM(InvoiceLine.UnitPrice * InvoiceLine.Quantity), 2) AS TotalRevenue\nFROM Artist\nJOIN Album ON Artist.ArtistId = Album.ArtistId\nJOIN Track ON Album.AlbumId = Track.AlbumId\nJOIN InvoiceLine ON Track.TrackId = InvoiceLine.TrackId\nJOIN Invoice ON InvoiceLine.InvoiceId = Invoice.InvoiceId\nGROUP BY Artist.ArtistId, Artist.Name\nORDER BY TotalTracksSold DESC\nLIMIT 5",
      "raw_output": "SELECT Artist.Name AS ArtistName, COUNT(*) AS TotalTracksSold, ROUND(SUM(InvoiceLine.UnitPrice * InvoiceLine.Quantity), 2) AS TotalRevenue\nFROM Artist\nJOIN Album ON Artist.ArtistId = Album.ArtistId\nJOIN Track ON Album.AlbumId = Track.AlbumId\nJOIN InvoiceLine ON Track.TrackId = InvoiceLine.TrackId\nJOIN Invoice ON InvoiceLine.InvoiceId = Invoice.InvoiceId\nGROUP BY Artist.ArtistId, Artist.Name\nORDER BY TotalTracksSold DESC\nLIMIT 5;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.58
    },
    {
      "query_id": "cte03",
      "concept_tag": "cte",
      "nl_question": "For each country, show the number of customers, total revenue, and average revenue per customer.",
      "model": "mistral-7b",
      "generated_sql": "SELECT\n    Country,\n    COUNT(CustomerId) AS NumberOfCustomers,\n    ROUND(SUM(Total), 2) AS TotalRevenue,\n    ROUND(AVG(Total), 2) AS AverageRevenuePerCustomer\nFROM\n    Customer c\nJOIN\n    Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY\n    Country\nORDER BY\n    Country",
      "raw_output": "SELECT\n    Country,\n    COUNT(CustomerId) AS NumberOfCustomers,\n    ROUND(SUM(Total), 2) AS TotalRevenue,\n    ROUND(AVG(Total), 2) AS AverageRevenuePerCustomer\nFROM\n    Customer c\nJOIN\n    Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY\n    Country\nORDER BY\n    Country;",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "ambiguous column name: CustomerId",
      "latency_s": 1.12
    },
    {
      "query_id": "cte04",
      "concept_tag": "cte",
      "nl_question": "Find all genres where the average track length is longer than the overall average track length across all genres.",
      "model": "mistral-7b",
      "generated_sql": "SELECT g.[Name] AS GenreName, ROUND(AVG(t.[Milliseconds])/1000.0, 2) AS AvgTrackLengthSeconds\nFROM [Genre] g\nJOIN [Track] t ON g.[GenreId] = t.[GenreId]\nGROUP BY g.[GenreId], g.[Name]\nHAVING ROUND(AVG(t.[Milliseconds])/1000.0, 2) > (\n    SELECT ROUND(AVG(t2.[Milliseconds])/1000.0, 2)\n    FROM [Track] t2\n)",
      "raw_output": "SELECT g.[Name] AS GenreName, ROUND(AVG(t.[Milliseconds])/1000.0, 2) AS AvgTrackLengthSeconds\nFROM [Genre] g\nJOIN [Track] t ON g.[GenreId] = t.[GenreId]\nGROUP BY g.[GenreId], g.[Name]\nHAVING ROUND(AVG(t.[Milliseconds])/1000.0, 2) > (\n    SELECT ROUND(AVG(t2.[Milliseconds])/1000.0, 2)\n    FROM [Track] t2\n)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 2.42
    },
    {
      "query_id": "cx01",
      "concept_tag": "complex_combination",
      "nl_question": "Rank customers by their total spending within each country, and show only the top 2 customers per country.",
      "model": "mistral-7b",
      "generated_sql": "WITH RankedCustomers AS (\n    SELECT\n        c.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        c.Country,\n        SUM(i.Total) AS TotalSpending\n    FROM\n        Customer c\n    JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        c.CustomerId, c.Country\n)\nSELECT\n    CustomerId,\n    CustomerName,\n    Country,\n    ROUND(TotalSpending, 2) AS TotalSpending\nFROM\n    RankedCustomers\nWHERE\n    (SELECT COUNT(DISTINCT CustomerId)\n     FROM RankedCustomers r\n     WHERE r.Country = RankedCustomers.Country) <= 2\n     OR RankedCustomers.CustomerId IN (\n         SELECT CustomerId\n         FROM RankedCustomers r\n         WHERE r.Country = RankedCustomers.Country\n         GROUP BY r.Country\n         ORDER BY SUM(r.TotalSpending) DESC\n         LIMIT 2\n     )",
      "raw_output": "WITH RankedCustomers AS (\n    SELECT\n        c.CustomerId,\n        c.FirstName || ' ' || c.LastName AS CustomerName,\n        c.Country,\n        SUM(i.Total) AS TotalSpending\n    FROM\n        Customer c\n    JOIN\n        Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY\n        c.CustomerId, c.Country\n)\nSELECT\n    CustomerId,\n    CustomerName,\n    Country,\n    ROUND(TotalSpending, 2) AS TotalSpending\nFROM\n    RankedCustomers\nWHERE\n    (SELECT COUNT(DISTINCT CustomerId)\n     FROM RankedCustomers r\n     WHERE r.Country = RankedCustomers.Country) <= 2\n     OR RankedCustomers.CustomerId IN (\n         SELECT CustomerId\n         FROM RankedCustomers r\n         WHERE r.Country = RankedCustomers.Country\n         GROUP BY r.Country\n         ORDER BY SUM(r.TotalSpending) DESC\n         LIMIT 2\n     )",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 33,
      "gen_row_count": 27,
      "missing_count": 33,
      "extra_count": 27,
      "latency_s": 2.4
    },
    {
      "query_id": "cx02",
      "concept_tag": "complex_combination",
      "nl_question": "Show each artist's share of total tracks in the database, but only for artists with more than 20 tracks.",
      "model": "mistral-7b",
      "generated_sql": "SELECT Artist.Name AS ArtistName,\n       ROUND(COUNT(Track.TrackId) * 100.0 / (SELECT COUNT(*) FROM Track), 2) AS ShareOfTotalTracks\nFROM Artist\nJOIN Track ON Artist.ArtistId = Track.AlbumId\nGROUP BY Artist.ArtistId\nHAVING COUNT(Track.TrackId) > 20",
      "raw_output": "SELECT Artist.Name AS ArtistName,\n       ROUND(COUNT(Track.TrackId) * 100.0 / (SELECT COUNT(*) FROM Track), 2) AS ShareOfTotalTracks\nFROM Artist\nJOIN Track ON Artist.ArtistId = Track.AlbumId\nGROUP BY Artist.ArtistId\nHAVING COUNT(Track.TrackId) > 20;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 52,
      "gen_row_count": 17,
      "missing_count": 52,
      "extra_count": 17,
      "latency_s": 1.05
    },
    {
      "query_id": "cx03",
      "concept_tag": "complex_combination",
      "nl_question": "Find the quarter with the highest revenue for each year in the database.",
      "model": "mistral-7b",
      "generated_sql": "WITH YearQuarterRevenue AS (\n    SELECT\n        strftime('%Y', Invoice.InvoiceDate) AS Year,\n        strftime('%m', Invoice.InvoiceDate) AS Month,\n        CASE\n            WHEN strftime('%m', Invoice.InvoiceDate) IN ('01', '02', '03') THEN 1\n            WHEN strftime('%m', Invoice.InvoiceDate) IN ('04', '05', '06') THEN 2\n            WHEN strftime('%m', Invoice.InvoiceDate) IN ('07', '08', '09') THEN 3\n            ELSE 4\n        END AS Quarter,\n        ROUND(SUM(Invoice.Total), 2) AS Revenue\n    FROM Invoice\n    GROUP BY Year, Quarter\n)\nSELECT Year, Quarter, Revenue\nFROM YearQuarterRevenue\nWHERE (Year, Revenue) IN (\n    SELECT Year, MAX(Revenue)\n    FROM YearQuarterRevenue\n    GROUP BY Year\n)",
      "raw_output": "WITH YearQuarterRevenue AS (\n    SELECT\n        strftime('%Y', Invoice.InvoiceDate) AS Year,\n        strftime('%m', Invoice.InvoiceDate) AS Month,\n        CASE\n            WHEN strftime('%m', Invoice.InvoiceDate) IN ('01', '02', '03') THEN 1\n            WHEN strftime('%m', Invoice.InvoiceDate) IN ('04', '05', '06') THEN 2\n            WHEN strftime('%m', Invoice.InvoiceDate) IN ('07', '08', '09') THEN 3\n            ELSE 4\n        END AS Quarter,\n        ROUND(SUM(Invoice.Total), 2) AS Revenue\n    FROM Invoice\n    GROUP BY Year, Quarter\n)\nSELECT Year, Quarter, Revenue\nFROM YearQuarterRevenue\nWHERE (Year, Revenue) IN (\n    SELECT Year, MAX(Revenue)\n    FROM YearQuarterRevenue\n    GROUP BY Year\n);",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 5,
      "gen_row_count": 7,
      "missing_count": 5,
      "extra_count": 7,
      "latency_s": 7.94
    },
    {
      "query_id": "cx04",
      "concept_tag": "complex_combination",
      "nl_question": "Show a playlist diversity score: for each playlist, count the number of distinct genres and distinct artists it contains.",
      "model": "mistral-7b",
      "generated_sql": "SELECT\n    p.[PlaylistId],\n    p.[Name] AS PlaylistName,\n    COUNT(DISTINCT t.[GenreId]) AS DistinctGenresCount,\n    COUNT(DISTINCT a.[ArtistId]) AS DistinctArtistsCount,\n    (SELECT COUNT(DISTINCT [GenreId]) FROM [Track] WHERE [AlbumId] IN (SELECT [AlbumId] FROM [Track] WHERE [TrackId] IN (SELECT [TrackId] FROM [PlaylistTrack] WHERE [PlaylistId] = p.[PlaylistId]))) AS PlaylistDistinctGenresCount,\n    (SELECT COUNT(DISTINCT [ArtistId]) FROM [Track] WHERE [TrackId] IN (SELECT [TrackId] FROM [PlaylistTrack] WHERE [PlaylistId] = p.[PlaylistId])) AS PlaylistDistinctArtistsCount\nFROM\n    [Playlist] p\nLEFT JOIN\n    [PlaylistTrack] pt ON p.[PlaylistId] = pt.[PlaylistId]\nLEFT JOIN\n    [Track] t ON pt.[TrackId] = t.[TrackId]\nGROUP BY\n    p.[PlaylistId], p.[Name]\nORDER BY\n    p.[PlaylistId]",
      "raw_output": "SELECT\n    p.[PlaylistId],\n    p.[Name] AS PlaylistName,\n    COUNT(DISTINCT t.[GenreId]) AS DistinctGenresCount,\n    COUNT(DISTINCT a.[ArtistId]) AS DistinctArtistsCount,\n    (SELECT COUNT(DISTINCT [GenreId]) FROM [Track] WHERE [AlbumId] IN (SELECT [AlbumId] FROM [Track] WHERE [TrackId] IN (SELECT [TrackId] FROM [PlaylistTrack] WHERE [PlaylistId] = p.[PlaylistId]))) AS PlaylistDistinctGenresCount,\n    (SELECT COUNT(DISTINCT [ArtistId]) FROM [Track] WHERE [TrackId] IN (SELECT [TrackId] FROM [PlaylistTrack] WHERE [PlaylistId] = p.[PlaylistId])) AS PlaylistDistinctArtistsCount\nFROM\n    [Playlist] p\nLEFT JOIN\n    [PlaylistTrack] pt ON p.[PlaylistId] = pt.[PlaylistId]\nLEFT JOIN\n    [Track] t ON pt.[TrackId] = t.[TrackId]\nGROUP BY\n    p.[PlaylistId], p.[Name]\nORDER BY\n    p.[PlaylistId];",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: a.ArtistId",
      "latency_s": 2.75
    },
    {
      "query_id": "ba01",
      "concept_tag": "basic",
      "nl_question": "List all customers from Brazil.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT FirstName || ' ' || LastName FROM Customer WHERE Country = 'Brazil'",
      "raw_output": "SELECT FirstName || ' ' || LastName FROM Customer WHERE Country = 'Brazil'",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 0.4
    },
    {
      "query_id": "ba02",
      "concept_tag": "basic",
      "nl_question": "How many tracks are in each genre? Show the genre name and count, ordered by count descending.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT Name, ROUND(COUNT(T1.TrackId), 2) AS TrackCount \nFROM Genre AS T1 \nJOIN Track AS T2 ON T1.GenreId = T2.GenreId \nGROUP BY T1.Name \nORDER BY TrackCount DESC",
      "raw_output": "SELECT Name, ROUND(COUNT(T1.TrackId), 2) AS TrackCount \nFROM Genre AS T1 \nJOIN Track AS T2 ON T1.GenreId = T2.GenreId \nGROUP BY T1.Name \nORDER BY TrackCount DESC",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "ambiguous column name: Name",
      "latency_s": 0.32
    },
    {
      "query_id": "ba03",
      "concept_tag": "basic",
      "nl_question": "Find the total number of invoices and the overall sum of invoice totals.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT COUNT(*) AS TotalInvoices, ROUND(SUM(Total), 2) AS TotalInvoiceSum FROM Invoice",
      "raw_output": "SELECT COUNT(*) AS TotalInvoices, ROUND(SUM(Total), 2) AS TotalInvoiceSum FROM Invoice",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 1,
      "gen_row_count": 1,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.28
    },
    {
      "query_id": "in01",
      "concept_tag": "intermediate",
      "nl_question": "Find all albums that have more than 20 tracks.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT T1.Title FROM Album AS T1 INNER JOIN Track AS T2 ON T1.AlbumId = T2.AlbumId GROUP BY T1.AlbumId HAVING COUNT(T2.TrackId) > 20",
      "raw_output": "SELECT T1.Title FROM Album AS T1 INNER JOIN Track AS T2 ON T1.AlbumId = T2.AlbumId GROUP BY T1.AlbumId HAVING COUNT(T2.TrackId) > 20",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 17,
      "gen_row_count": 17,
      "missing_count": 17,
      "extra_count": 17,
      "latency_s": 0.37
    },
    {
      "query_id": "in02",
      "concept_tag": "intermediate",
      "nl_question": "Which customers have placed more than 5 invoices? Show their name and invoice count.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT FirstName || ' ' || LastName, COUNT(T1.InvoiceId) AS InvoiceCount \nFROM Customer AS T1 \nJOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId \nGROUP BY T1.CustomerId \nHAVING COUNT(T1.CustomerId) > 5",
      "raw_output": "SELECT FirstName || ' ' || LastName, COUNT(T1.InvoiceId) AS InvoiceCount \nFROM Customer AS T1 \nJOIN Invoice AS T2 ON T1.CustomerId = T2.CustomerId \nGROUP BY T1.CustomerId \nHAVING COUNT(T1.CustomerId) > 5",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: T1.InvoiceId",
      "latency_s": 0.3
    },
    {
      "query_id": "in03",
      "concept_tag": "intermediate",
      "nl_question": "Find the top 10 most purchased tracks, showing the track name, artist, and number of times purchased.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT T1.Name, \n       (SELECT T3.Name FROM Track AS T3 INNER JOIN Album AS T4 ON T3.AlbumId = T4.AlbumId WHERE T3.TrackId = T2.TrackId) AS Artist, \n       ROUND(COUNT(T2.TrackId), 2) AS NumPurchased\nFROM InvoiceLine AS T2\nINNER JOIN Track AS T1 ON T2.TrackId = T1.TrackId\nGROUP BY T1.TrackId\nORDER BY COUNT(T2.TrackId) DESC\nLIMIT 10",
      "raw_output": "SELECT T1.Name, \n       (SELECT T3.Name FROM Track AS T3 INNER JOIN Album AS T4 ON T3.AlbumId = T4.AlbumId WHERE T3.TrackId = T2.TrackId) AS Artist, \n       ROUND(COUNT(T2.TrackId), 2) AS NumPurchased\nFROM InvoiceLine AS T2\nINNER JOIN Track AS T1 ON T2.TrackId = T1.TrackId\nGROUP BY T1.TrackId\nORDER BY COUNT(T2.TrackId) DESC\nLIMIT 10",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 10,
      "gen_row_count": 10,
      "missing_count": 10,
      "extra_count": 10,
      "latency_s": 0.35
    },
    {
      "query_id": "wf01",
      "concept_tag": "window_function",
      "nl_question": "For each genre, rank the tracks by unit price descending and show the top 3 most expensive tracks per genre.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT g.Name, t.Name, ROUND(t.UnitPrice, 2) \nFROM (\n  SELECT g.Name, t.Name, t.UnitPrice, \n  DENSE_RANK() OVER (PARTITION BY g.Name ORDER BY t.UnitPrice DESC) AS rk \n  FROM Track t \n  JOIN Genre g ON t.GenreId = g.GenreId\n) AS subquery \nWHERE rk <= 3",
      "raw_output": "SELECT g.Name, t.Name, ROUND(t.UnitPrice, 2) \nFROM (\n  SELECT g.Name, t.Name, t.UnitPrice, \n  DENSE_RANK() OVER (PARTITION BY g.Name ORDER BY t.UnitPrice DESC) AS rk \n  FROM Track t \n  JOIN Genre g ON t.GenreId = g.GenreId\n) AS subquery \nWHERE rk <= 3",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: g.Name",
      "latency_s": 0.37
    },
    {
      "query_id": "wf02",
      "concept_tag": "window_function",
      "nl_question": "Show each employee's total sales alongside the running total of sales across all employees ordered by total sales descending.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT e.FirstName || ' ' || e.LastName AS EmployeeName, \n       ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS EmployeeSales, \n       ROUND(SUM(SUM(il.UnitPrice * il.Quantity)) OVER (ORDER BY SUM(il.UnitPrice * il.Quantity) DESC), 2) AS RunningTotal\nFROM Employee e\nJOIN Invoice i ON e.EmployeeId = i.CustomerSupportEmployeeId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY e.EmployeeId",
      "raw_output": "SELECT e.FirstName || ' ' || e.LastName AS EmployeeName, \n       ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS EmployeeSales, \n       ROUND(SUM(SUM(il.UnitPrice * il.Quantity)) OVER (ORDER BY SUM(il.UnitPrice * il.Quantity) DESC), 2) AS RunningTotal\nFROM Employee e\nJOIN Invoice i ON e.EmployeeId = i.CustomerSupportEmployeeId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY e.EmployeeId",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: i.CustomerSupportEmployeeId",
      "latency_s": 0.31
    },
    {
      "query_id": "wf03",
      "concept_tag": "window_function",
      "nl_question": "For each customer, show their invoice totals and the percentage each invoice contributes to their overall spending.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT c.CustomerId, c.FirstName || ' ' || c.LastName, i.InvoiceId, i.InvoiceDate, ROUND(i.Total, 2) AS InvoiceTotal, \n       ROUND(i.Total * 100 / (SELECT SUM(Total) FROM Invoice WHERE CustomerId = c.CustomerId), 2) AS ContributionPercentage\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId",
      "raw_output": "SELECT c.CustomerId, c.FirstName || ' ' || c.LastName, i.InvoiceId, i.InvoiceDate, ROUND(i.Total, 2) AS InvoiceTotal, \n       ROUND(i.Total * 100 / (SELECT SUM(Total) FROM Invoice WHERE CustomerId = c.CustomerId), 2) AS ContributionPercentage\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 412,
      "gen_row_count": 412,
      "missing_count": 412,
      "extra_count": 412,
      "latency_s": 0.38
    },
    {
      "query_id": "wf04",
      "concept_tag": "window_function",
      "nl_question": "Show the month-over-month change in total invoice amounts for each year-month combination.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT \n  strftime('%Y', i.InvoiceDate) AS Year,\n  strftime('%m', i.InvoiceDate) AS Month,\n  ROUND(SUM(i.Total), 2) AS TotalInvoiceAmount,\n  ROUND(SUM(CASE WHEN strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) - 1 THEN i.Total ELSE 0 END), 2) AS PreviousYearTotal,\n  ROUND((SUM(i.Total) - SUM(CASE WHEN strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) - 1 THEN i.Total ELSE 0 END)) / SUM(CASE WHEN strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) - 1 THEN i.Total ELSE 0 END) * 100, 2) AS MonthOverMonthChange\nFROM Invoice i\nLEFT JOIN Invoice l ON strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) + 1 AND strftime('%m', i.InvoiceDate) = strftime('%m', l.InvoiceDate)\nGROUP BY strftime('%Y', i.InvoiceDate), strftime('%m', i.InvoiceDate)",
      "raw_output": "SELECT \n  strftime('%Y', i.InvoiceDate) AS Year,\n  strftime('%m', i.InvoiceDate) AS Month,\n  ROUND(SUM(i.Total), 2) AS TotalInvoiceAmount,\n  ROUND(SUM(CASE WHEN strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) - 1 THEN i.Total ELSE 0 END), 2) AS PreviousYearTotal,\n  ROUND((SUM(i.Total) - SUM(CASE WHEN strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) - 1 THEN i.Total ELSE 0 END)) / SUM(CASE WHEN strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) - 1 THEN i.Total ELSE 0 END) * 100, 2) AS MonthOverMonthChange\nFROM Invoice i\nLEFT JOIN Invoice l ON strftime('%Y', i.InvoiceDate) = strftime('%Y', l.InvoiceDate) + 1 AND strftime('%m', i.InvoiceDate) = strftime('%m', l.InvoiceDate)\nGROUP BY strftime('%Y', i.InvoiceDate), strftime('%m', i.InvoiceDate)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 60,
      "gen_row_count": 60,
      "missing_count": 60,
      "extra_count": 60,
      "latency_s": 0.38
    },
    {
      "query_id": "cte01",
      "concept_tag": "cte",
      "nl_question": "Find customers who have spent more than the average customer lifetime value.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT c.CustomerId, c.FirstName || ' ' || c.LastName, ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS TotalSpent\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.CustomerId, c.FirstName, c.LastName\nHAVING SUM(il.UnitPrice * il.Quantity) > (SELECT ROUND(AVG(SUM(il.UnitPrice * il.Quantity)), 2) FROM Customer c JOIN Invoice i ON c.CustomerId = i.CustomerId JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId)",
      "raw_output": "SELECT c.CustomerId, c.FirstName || ' ' || c.LastName, ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS TotalSpent\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY c.CustomerId, c.FirstName, c.LastName\nHAVING SUM(il.UnitPrice * il.Quantity) > (SELECT ROUND(AVG(SUM(il.UnitPrice * il.Quantity)), 2) FROM Customer c JOIN Invoice i ON c.CustomerId = i.CustomerId JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId)",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "misuse of aggregate function SUM()",
      "latency_s": 0.41
    },
    {
      "query_id": "cte02",
      "concept_tag": "cte",
      "nl_question": "Find the top 5 artists by number of tracks sold, along with their total revenue.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT \n  a.Name, \n  SUM(il.UnitPrice * il.Quantity) AS TotalRevenue\nFROM \n  Artist a\n  JOIN Track t ON a.ArtistId = t.GenreId\n  JOIN InvoiceLine il ON t.TrackId = il.TrackId\nGROUP BY \n  a.Name\nORDER BY \n  TotalRevenue DESC\nLIMIT 5",
      "raw_output": "SELECT \n  a.Name, \n  SUM(il.UnitPrice * il.Quantity) AS TotalRevenue\nFROM \n  Artist a\n  JOIN Track t ON a.ArtistId = t.GenreId\n  JOIN InvoiceLine il ON t.TrackId = il.TrackId\nGROUP BY \n  a.Name\nORDER BY \n  TotalRevenue DESC\nLIMIT 5",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 0.37
    },
    {
      "query_id": "cte03",
      "concept_tag": "cte",
      "nl_question": "For each country, show the number of customers, total revenue, and average revenue per customer.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT \n  Country, \n  COUNT(CustomerId) AS NumCustomers, \n  ROUND(SUM(Total), 2) AS TotalRevenue, \n  ROUND(AVG(Total), 2) AS AvgRevenuePerCustomer\nFROM \n  Invoice\nGROUP BY \n  Country",
      "raw_output": "SELECT \n  Country, \n  COUNT(CustomerId) AS NumCustomers, \n  ROUND(SUM(Total), 2) AS TotalRevenue, \n  ROUND(AVG(Total), 2) AS AvgRevenuePerCustomer\nFROM \n  Invoice\nGROUP BY \n  Country",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: Country",
      "latency_s": 0.34
    },
    {
      "query_id": "cte04",
      "concept_tag": "cte",
      "nl_question": "Find all genres where the average track length is longer than the overall average track length across all genres.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT Name FROM Genre WHERE Name IN (SELECT T1.Name FROM Genre AS T1 INNER JOIN Track AS T2 ON T1.GenreId = T2.GenreId GROUP BY T1.Name HAVING ROUND(AVG(T2.Milliseconds) / 60000, 2) > (SELECT ROUND(AVG(Milliseconds) / 60000, 2) FROM Track))",
      "raw_output": "SELECT Name FROM Genre WHERE Name IN (SELECT T1.Name FROM Genre AS T1 INNER JOIN Track AS T2 ON T1.GenreId = T2.GenreId GROUP BY T1.Name HAVING ROUND(AVG(T2.Milliseconds) / 60000, 2) > (SELECT ROUND(AVG(Milliseconds) / 60000, 2) FROM Track))",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 0.28
    },
    {
      "query_id": "cx01",
      "concept_tag": "complex_combination",
      "nl_question": "Rank customers by their total spending within each country, and show only the top 2 customers per country.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT c.FirstName || ' ' || c.LastName, c.Country, ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS TotalSpending \nFROM Customer c \nJOIN Invoice i ON c.CustomerId = i.CustomerId \nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId \nGROUP BY c.Country, c.FirstName, c.LastName \nORDER BY c.Country, TotalSpending DESC \nHAVING COUNT(*) <= 2",
      "raw_output": "SELECT c.FirstName || ' ' || c.LastName, c.Country, ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS TotalSpending \nFROM Customer c \nJOIN Invoice i ON c.CustomerId = i.CustomerId \nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId \nGROUP BY c.Country, c.FirstName, c.LastName \nORDER BY c.Country, TotalSpending DESC \nHAVING COUNT(*) <= 2",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "near \"HAVING\": syntax error",
      "latency_s": 0.3
    },
    {
      "query_id": "cx02",
      "concept_tag": "complex_combination",
      "nl_question": "Show each artist's share of total tracks in the database, but only for artists with more than 20 tracks.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT ROUND((COUNT(T1.TrackId) * 1.0 / (SELECT COUNT(TrackId) FROM Track)) * 100, 2) AS ArtistShare, \n       T2.Name AS ArtistName\nFROM Track AS T1\nJOIN Album AS T2 ON T1.AlbumId = T2.AlbumId\nJOIN Artist AS T3 ON T2.ArtistId = T3.ArtistId\nGROUP BY T3.Name\nHAVING COUNT(T1.TrackId) > 20",
      "raw_output": "SELECT ROUND((COUNT(T1.TrackId) * 1.0 / (SELECT COUNT(TrackId) FROM Track)) * 100, 2) AS ArtistShare, \n       T2.Name AS ArtistName\nFROM Track AS T1\nJOIN Album AS T2 ON T1.AlbumId = T2.AlbumId\nJOIN Artist AS T3 ON T2.ArtistId = T3.ArtistId\nGROUP BY T3.Name\nHAVING COUNT(T1.TrackId) > 20",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: T2.Name",
      "latency_s": 0.3
    },
    {
      "query_id": "cx03",
      "concept_tag": "complex_combination",
      "nl_question": "Find the quarter with the highest revenue for each year in the database.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT \n  strftime('%Y', i.InvoiceDate) AS Year, \n  strftime('%q', i.InvoiceDate) AS Quarter, \n  ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS Revenue\nFROM Invoice i\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY strftime('%Y', i.InvoiceDate), strftime('%q', i.InvoiceDate)\nORDER BY Year, Revenue DESC\nHAVING Revenue = (SELECT ROUND(SUM(il.UnitPrice * il.Quantity), 2) \n                  FROM Invoice i\n                  JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\n                  WHERE strftime('%Y', i.InvoiceDate) = strftime('%Y', i.InvoiceDate)\n                  GROUP BY strftime('%Y', i.InvoiceDate), strftime('%q', i.InvoiceDate)\n                  ORDER BY Year, Revenue DESC\n                  LIMIT 1)",
      "raw_output": "SELECT \n  strftime('%Y', i.InvoiceDate) AS Year, \n  strftime('%q', i.InvoiceDate) AS Quarter, \n  ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS Revenue\nFROM Invoice i\nJOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\nGROUP BY strftime('%Y', i.InvoiceDate), strftime('%q', i.InvoiceDate)\nORDER BY Year, Revenue DESC\nHAVING Revenue = (SELECT ROUND(SUM(il.UnitPrice * il.Quantity), 2) \n                  FROM Invoice i\n                  JOIN InvoiceLine il ON i.InvoiceId = il.InvoiceId\n                  WHERE strftime('%Y', i.InvoiceDate) = strftime('%Y', i.InvoiceDate)\n                  GROUP BY strftime('%Y', i.InvoiceDate), strftime('%q', i.InvoiceDate)\n                  ORDER BY Year, Revenue DESC\n                  LIMIT 1)",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "near \"HAVING\": syntax error",
      "latency_s": 0.33
    },
    {
      "query_id": "cx04",
      "concept_tag": "complex_combination",
      "nl_question": "Show a playlist diversity score: for each playlist, count the number of distinct genres and distinct artists it contains.",
      "model": "llama-3.1-8b",
      "generated_sql": "SELECT p.PlaylistId, p.Name, COUNT(DISTINCT g.Name) AS DistinctGenres, COUNT(DISTINCT a.Name) AS DistinctArtists\nFROM Playlist p\nJOIN PlaylistTrack pt ON p.PlaylistId = pt.PlaylistId\nJOIN Track t ON pt.TrackId = t.TrackId\nJOIN Genre g ON t.GenreId = g.GenreId\nJOIN Album a ON t.AlbumId = a.AlbumId\nGROUP BY p.PlaylistId, p.Name",
      "raw_output": "SELECT p.PlaylistId, p.Name, COUNT(DISTINCT g.Name) AS DistinctGenres, COUNT(DISTINCT a.Name) AS DistinctArtists\nFROM Playlist p\nJOIN PlaylistTrack pt ON p.PlaylistId = pt.PlaylistId\nJOIN Track t ON pt.TrackId = t.TrackId\nJOIN Genre g ON t.GenreId = g.GenreId\nJOIN Album a ON t.AlbumId = a.AlbumId\nGROUP BY p.PlaylistId, p.Name",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "no such column: a.Name",
      "latency_s": 0.3
    },
    {
      "query_id": "ba01",
      "concept_tag": "basic",
      "nl_question": "List all customers from Brazil.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT CustomerId, FirstName || ' ' || LastName AS FullName, Email\nFROM Customer\nWHERE Country = 'Brazil'",
      "raw_output": "SELECT CustomerId, FirstName || ' ' || LastName AS FullName, Email\nFROM Customer\nWHERE Country = 'Brazil'",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 0.83
    },
    {
      "query_id": "ba02",
      "concept_tag": "basic",
      "nl_question": "How many tracks are in each genre? Show the genre name and count, ordered by count descending.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT g.Name, COUNT(t.TrackId) AS Count\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nGROUP BY g.Name\nORDER BY Count DESC",
      "raw_output": "SELECT g.Name, COUNT(t.TrackId) AS Count\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nGROUP BY g.Name\nORDER BY Count DESC",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 25,
      "gen_row_count": 25,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.81
    },
    {
      "query_id": "ba03",
      "concept_tag": "basic",
      "nl_question": "Find the total number of invoices and the overall sum of invoice totals.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT COUNT(*) AS TotalInvoices, SUM(Total) AS OverallSum\nFROM Invoice",
      "raw_output": "SELECT COUNT(*) AS TotalInvoices, SUM(Total) AS OverallSum\nFROM Invoice;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 1,
      "gen_row_count": 1,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.48
    },
    {
      "query_id": "in01",
      "concept_tag": "intermediate",
      "nl_question": "Find all albums that have more than 20 tracks.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT a.Title\nFROM Album a\nJOIN Track t ON a.AlbumId = t.AlbumId\nGROUP BY a.AlbumId, a.Title\nHAVING COUNT(t.TrackId) > 20\nORDER BY a.Title",
      "raw_output": "SELECT a.Title\nFROM Album a\nJOIN Track t ON a.AlbumId = t.AlbumId\nGROUP BY a.AlbumId, a.Title\nHAVING COUNT(t.TrackId) > 20\nORDER BY a.Title;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 17,
      "gen_row_count": 17,
      "missing_count": 17,
      "extra_count": 17,
      "latency_s": 0.62
    },
    {
      "query_id": "in02",
      "concept_tag": "intermediate",
      "nl_question": "Which customers have placed more than 5 invoices? Show their name and invoice count.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT c.FirstName || ' ' || c.LastName AS CustomerName, COUNT(i.InvoiceId) AS InvoiceCount\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY c.CustomerId, c.FirstName, c.LastName\nHAVING COUNT(i.InvoiceId) > 5\nORDER BY InvoiceCount DESC",
      "raw_output": "SELECT c.FirstName || ' ' || c.LastName AS CustomerName, COUNT(i.InvoiceId) AS InvoiceCount\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY c.CustomerId, c.FirstName, c.LastName\nHAVING COUNT(i.InvoiceId) > 5\nORDER BY InvoiceCount DESC;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 59,
      "gen_row_count": 59,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.75
    },
    {
      "query_id": "in03",
      "concept_tag": "intermediate",
      "nl_question": "Find the top 10 most purchased tracks, showing the track name, artist, and number of times purchased.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT t.Name AS TrackName, a.Name AS Artist, COUNT(il.TrackId) AS TimesPurchased\nFROM InvoiceLine il\nJOIN Track t ON il.TrackId = t.TrackId\nJOIN Album al ON t.AlbumId = al.AlbumId\nJOIN Artist a ON al.ArtistId = a.ArtistId\nGROUP BY il.TrackId, t.Name, a.Name\nORDER BY TimesPurchased DESC\nLIMIT 10",
      "raw_output": "SELECT t.Name AS TrackName, a.Name AS Artist, COUNT(il.TrackId) AS TimesPurchased\nFROM InvoiceLine il\nJOIN Track t ON il.TrackId = t.TrackId\nJOIN Album al ON t.AlbumId = al.AlbumId\nJOIN Artist a ON al.ArtistId = a.ArtistId\nGROUP BY il.TrackId, t.Name, a.Name\nORDER BY TimesPurchased DESC\nLIMIT 10;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 10,
      "gen_row_count": 10,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.5
    },
    {
      "query_id": "wf01",
      "concept_tag": "window_function",
      "nl_question": "For each genre, rank the tracks by unit price descending and show the top 3 most expensive tracks per genre.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT GenreName, TrackName, UnitPrice, RankInGenre\nFROM (\n    SELECT \n        g.Name AS GenreName,\n        t.Name AS TrackName,\n        t.UnitPrice,\n        ROW_NUMBER() OVER (PARTITION BY g.GenreId ORDER BY t.UnitPrice DESC) AS RankInGenre\n    FROM Track t\n    JOIN Genre g ON t.GenreId = g.GenreId\n) ranked_tracks\nWHERE RankInGenre <= 3\nORDER BY GenreName, RankInGenre",
      "raw_output": "SELECT GenreName, TrackName, UnitPrice, RankInGenre\nFROM (\n    SELECT \n        g.Name AS GenreName,\n        t.Name AS TrackName,\n        t.UnitPrice,\n        ROW_NUMBER() OVER (PARTITION BY g.GenreId ORDER BY t.UnitPrice DESC) AS RankInGenre\n    FROM Track t\n    JOIN Genre g ON t.GenreId = g.GenreId\n) ranked_tracks\nWHERE RankInGenre <= 3\nORDER BY GenreName, RankInGenre;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 73,
      "gen_row_count": 73,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.43
    },
    {
      "query_id": "wf02",
      "concept_tag": "window_function",
      "nl_question": "Show each employee's total sales alongside the running total of sales across all employees ordered by total sales descending.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    e.FirstName || ' ' || e.LastName AS EmployeeName,\n    ROUND(SUM(i.Total), 2) AS TotalSales,\n    ROUND(SUM(SUM(i.Total)) OVER (ORDER BY SUM(i.Total) DESC), 2) AS RunningTotal\nFROM Employee e\nJOIN Customer c ON e.EmployeeId = c.SupportRepId\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY e.EmployeeId, e.FirstName, e.LastName\nORDER BY TotalSales DESC",
      "raw_output": "SELECT \n    e.FirstName || ' ' || e.LastName AS EmployeeName,\n    ROUND(SUM(i.Total), 2) AS TotalSales,\n    ROUND(SUM(SUM(i.Total)) OVER (ORDER BY SUM(i.Total) DESC), 2) AS RunningTotal\nFROM Employee e\nJOIN Customer c ON e.EmployeeId = c.SupportRepId\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY e.EmployeeId, e.FirstName, e.LastName\nORDER BY TotalSales DESC;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 3,
      "gen_row_count": 3,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 0.96
    },
    {
      "query_id": "wf03",
      "concept_tag": "window_function",
      "nl_question": "For each customer, show their invoice totals and the percentage each invoice contributes to their overall spending.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    c.CustomerId,\n    c.FirstName || ' ' || c.LastName AS CustomerName,\n    i.InvoiceId,\n    i.Total AS InvoiceTotal,\n    ROUND((i.Total / SUM(i.Total) OVER (PARTITION BY c.CustomerId)) * 100, 2) AS PercentageOfSpending\nFROM \n    Customer c\nJOIN \n    Invoice i ON c.CustomerId = i.CustomerId\nORDER BY \n    c.CustomerId, i.InvoiceId",
      "raw_output": "SELECT \n    c.CustomerId,\n    c.FirstName || ' ' || c.LastName AS CustomerName,\n    i.InvoiceId,\n    i.Total AS InvoiceTotal,\n    ROUND((i.Total / SUM(i.Total) OVER (PARTITION BY c.CustomerId)) * 100, 2) AS PercentageOfSpending\nFROM \n    Customer c\nJOIN \n    Invoice i ON c.CustomerId = i.CustomerId\nORDER BY \n    c.CustomerId, i.InvoiceId;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 412,
      "gen_row_count": 412,
      "missing_count": 412,
      "extra_count": 412,
      "latency_s": 1.13
    },
    {
      "query_id": "wf04",
      "concept_tag": "window_function",
      "nl_question": "Show the month-over-month change in total invoice amounts for each year-month combination.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    strftime('%Y-%m', InvoiceDate) AS YearMonth,\n    ROUND(SUM(Total), 2) AS TotalAmount,\n    ROUND(SUM(Total) - LAG(SUM(Total)) OVER (ORDER BY strftime('%Y-%m', InvoiceDate)), 2) AS MonthOverMonthChange\nFROM Invoice\nGROUP BY strftime('%Y-%m', InvoiceDate)\nORDER BY YearMonth",
      "raw_output": "SELECT \n    strftime('%Y-%m', InvoiceDate) AS YearMonth,\n    ROUND(SUM(Total), 2) AS TotalAmount,\n    ROUND(SUM(Total) - LAG(SUM(Total)) OVER (ORDER BY strftime('%Y-%m', InvoiceDate)), 2) AS MonthOverMonthChange\nFROM Invoice\nGROUP BY strftime('%Y-%m', InvoiceDate)\nORDER BY YearMonth;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 60,
      "gen_row_count": 60,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.02
    },
    {
      "query_id": "cte01",
      "concept_tag": "cte",
      "nl_question": "Find customers who have spent more than the average customer lifetime value.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT c.CustomerId, c.FirstName || ' ' || c.LastName AS CustomerName\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY c.CustomerId, c.FirstName, c.LastName\nHAVING SUM(i.Total) > (\n    SELECT AVG(total_spent)\n    FROM (\n        SELECT SUM(i2.Total) AS total_spent\n        FROM Customer c2\n        JOIN Invoice i2 ON c2.CustomerId = i2.CustomerId\n        GROUP BY c2.CustomerId\n    )\n)",
      "raw_output": "SELECT c.CustomerId, c.FirstName || ' ' || c.LastName AS CustomerName\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY c.CustomerId, c.FirstName, c.LastName\nHAVING SUM(i.Total) > (\n    SELECT AVG(total_spent)\n    FROM (\n        SELECT SUM(i2.Total) AS total_spent\n        FROM Customer c2\n        JOIN Invoice i2 ON c2.CustomerId = i2.CustomerId\n        GROUP BY c2.CustomerId\n    )\n)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 22,
      "gen_row_count": 22,
      "missing_count": 22,
      "extra_count": 22,
      "latency_s": 1.03
    },
    {
      "query_id": "cte02",
      "concept_tag": "cte",
      "nl_question": "Find the top 5 artists by number of tracks sold, along with their total revenue.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    ar.Name AS ArtistName,\n    COUNT(il.TrackId) AS TracksSold,\n    ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS TotalRevenue\nFROM Artist ar\nJOIN Album al ON ar.ArtistId = al.ArtistId\nJOIN Track t ON al.AlbumId = t.AlbumId\nJOIN InvoiceLine il ON t.TrackId = il.TrackId\nGROUP BY ar.ArtistId, ar.Name\nORDER BY TracksSold DESC\nLIMIT 5",
      "raw_output": "SELECT \n    ar.Name AS ArtistName,\n    COUNT(il.TrackId) AS TracksSold,\n    ROUND(SUM(il.UnitPrice * il.Quantity), 2) AS TotalRevenue\nFROM Artist ar\nJOIN Album al ON ar.ArtistId = al.ArtistId\nJOIN Track t ON al.AlbumId = t.AlbumId\nJOIN InvoiceLine il ON t.TrackId = il.TrackId\nGROUP BY ar.ArtistId, ar.Name\nORDER BY TracksSold DESC\nLIMIT 5;",
      "execution_success": true,
      "exact_match": true,
      "fuzzy_match": true,
      "row_count_match": true,
      "row_overlap_pct": 100.0,
      "result_match": true,
      "failure_mode": null,
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 0,
      "extra_count": 0,
      "latency_s": 1.32
    },
    {
      "query_id": "cte03",
      "concept_tag": "cte",
      "nl_question": "For each country, show the number of customers, total revenue, and average revenue per customer.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    Country,\n    COUNT(CustomerId) AS NumberOfCustomers,\n    ROUND(SUM(Total), 2) AS TotalRevenue,\n    ROUND(SUM(Total) / COUNT(CustomerId), 2) AS AverageRevenuePerCustomer\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY Country\nORDER BY TotalRevenue DESC",
      "raw_output": "SELECT \n    Country,\n    COUNT(CustomerId) AS NumberOfCustomers,\n    ROUND(SUM(Total), 2) AS TotalRevenue,\n    ROUND(SUM(Total) / COUNT(CustomerId), 2) AS AverageRevenuePerCustomer\nFROM Customer c\nJOIN Invoice i ON c.CustomerId = i.CustomerId\nGROUP BY Country\nORDER BY TotalRevenue DESC;",
      "execution_success": false,
      "result_match": false,
      "failure_mode": "execution_error",
      "error_detail": "ambiguous column name: CustomerId",
      "latency_s": 1.29
    },
    {
      "query_id": "cte04",
      "concept_tag": "cte",
      "nl_question": "Find all genres where the average track length is longer than the overall average track length across all genres.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT g.Name\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nGROUP BY g.GenreId, g.Name\nHAVING AVG(t.Milliseconds) > (\n    SELECT AVG(Milliseconds)\n    FROM Track\n)",
      "raw_output": "SELECT g.Name\nFROM Genre g\nJOIN Track t ON g.GenreId = t.GenreId\nGROUP BY g.GenreId, g.Name\nHAVING AVG(t.Milliseconds) > (\n    SELECT AVG(Milliseconds)\n    FROM Track\n)",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 1.12
    },
    {
      "query_id": "cx01",
      "concept_tag": "complex_combination",
      "nl_question": "Rank customers by their total spending within each country, and show only the top 2 customers per country.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT Country, FirstName, LastName, TotalSpending\nFROM (\n    SELECT c.Country, c.FirstName, c.LastName, SUM(i.Total) AS TotalSpending,\n           ROW_NUMBER() OVER (PARTITION BY c.Country ORDER BY SUM(i.Total) DESC) AS rn\n    FROM Customer c\n    JOIN Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY c.Country, c.CustomerId, c.FirstName, c.LastName\n) ranked\nWHERE rn <= 2\nORDER BY Country, TotalSpending DESC",
      "raw_output": "SELECT Country, FirstName, LastName, TotalSpending\nFROM (\n    SELECT c.Country, c.FirstName, c.LastName, SUM(i.Total) AS TotalSpending,\n           ROW_NUMBER() OVER (PARTITION BY c.Country ORDER BY SUM(i.Total) DESC) AS rn\n    FROM Customer c\n    JOIN Invoice i ON c.CustomerId = i.CustomerId\n    GROUP BY c.Country, c.CustomerId, c.FirstName, c.LastName\n) ranked\nWHERE rn <= 2\nORDER BY Country, TotalSpending DESC;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 33,
      "gen_row_count": 33,
      "missing_count": 33,
      "extra_count": 33,
      "latency_s": 1.17
    },
    {
      "query_id": "cx02",
      "concept_tag": "complex_combination",
      "nl_question": "Show each artist's share of total tracks in the database, but only for artists with more than 20 tracks.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    ar.Name,\n    ROUND(COUNT(t.TrackId) * 100.0 / (SELECT COUNT(*) FROM Track), 2) AS ShareOfTotalTracks\nFROM Artist ar\nJOIN Album al ON ar.ArtistId = al.ArtistId\nJOIN Track t ON al.AlbumId = t.AlbumId\nGROUP BY ar.ArtistId, ar.Name\nHAVING COUNT(t.TrackId) > 20\nORDER BY ShareOfTotalTracks DESC",
      "raw_output": "SELECT \n    ar.Name,\n    ROUND(COUNT(t.TrackId) * 100.0 / (SELECT COUNT(*) FROM Track), 2) AS ShareOfTotalTracks\nFROM Artist ar\nJOIN Album al ON ar.ArtistId = al.ArtistId\nJOIN Track t ON al.AlbumId = t.AlbumId\nGROUP BY ar.ArtistId, ar.Name\nHAVING COUNT(t.TrackId) > 20\nORDER BY ShareOfTotalTracks DESC;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 52,
      "gen_row_count": 52,
      "missing_count": 52,
      "extra_count": 52,
      "latency_s": 1.13
    },
    {
      "query_id": "cx03",
      "concept_tag": "complex_combination",
      "nl_question": "Find the quarter with the highest revenue for each year in the database.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n  year,\n  quarter,\n  revenue\nFROM (\n  SELECT \n    strftime('%Y', InvoiceDate) AS year,\n    CASE \n      WHEN strftime('%m', InvoiceDate) IN ('01', '02', '03') THEN 1\n      WHEN strftime('%m', InvoiceDate) IN ('04', '05', '06') THEN 2\n      WHEN strftime('%m', InvoiceDate) IN ('07', '08', '09') THEN 3\n      ELSE 4\n    END AS quarter,\n    SUM(Total) AS revenue,\n    ROW_NUMBER() OVER (\n      PARTITION BY strftime('%Y', InvoiceDate)\n      ORDER BY SUM(Total) DESC\n    ) AS rn\n  FROM Invoice\n  GROUP BY \n    strftime('%Y', InvoiceDate),\n    CASE \n      WHEN strftime('%m', InvoiceDate) IN ('01', '02', '03') THEN 1\n      WHEN strftime('%m', InvoiceDate) IN ('04', '05', '06') THEN 2\n      WHEN strftime('%m', InvoiceDate) IN ('07', '08', '09') THEN 3\n      ELSE 4\n    END\n) ranked\nWHERE rn = 1\nORDER BY year",
      "raw_output": "SELECT \n  year,\n  quarter,\n  revenue\nFROM (\n  SELECT \n    strftime('%Y', InvoiceDate) AS year,\n    CASE \n      WHEN strftime('%m', InvoiceDate) IN ('01', '02', '03') THEN 1\n      WHEN strftime('%m', InvoiceDate) IN ('04', '05', '06') THEN 2\n      WHEN strftime('%m', InvoiceDate) IN ('07', '08', '09') THEN 3\n      ELSE 4\n    END AS quarter,\n    SUM(Total) AS revenue,\n    ROW_NUMBER() OVER (\n      PARTITION BY strftime('%Y', InvoiceDate)\n      ORDER BY SUM(Total) DESC\n    ) AS rn\n  FROM Invoice\n  GROUP BY \n    strftime('%Y', InvoiceDate),\n    CASE \n      WHEN strftime('%m', InvoiceDate) IN ('01', '02', '03') THEN 1\n      WHEN strftime('%m', InvoiceDate) IN ('04', '05', '06') THEN 2\n      WHEN strftime('%m', InvoiceDate) IN ('07', '08', '09') THEN 3\n      ELSE 4\n    END\n) ranked\nWHERE rn = 1\nORDER BY year;",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": true,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_values",
      "gt_row_count": 5,
      "gen_row_count": 5,
      "missing_count": 5,
      "extra_count": 5,
      "latency_s": 5.05
    },
    {
      "query_id": "cx04",
      "concept_tag": "complex_combination",
      "nl_question": "Show a playlist diversity score: for each playlist, count the number of distinct genres and distinct artists it contains.",
      "model": "qwen2.5-coder-32b",
      "generated_sql": "SELECT \n    p.[PlaylistId],\n    p.[Name],\n    COUNT(DISTINCT t.[GenreId]) AS GenreCount,\n    COUNT(DISTINCT a.[ArtistId]) AS ArtistCount\nFROM \n    [Playlist] p\nJOIN \n    [PlaylistTrack] pt ON p.[PlaylistId] = pt.[PlaylistId]\nJOIN \n    [Track] t ON pt.[TrackId] = t.[TrackId]\nJOIN \n    [Album] a ON t.[AlbumId] = a.[AlbumId]\nGROUP BY \n    p.[PlaylistId], p.[Name]",
      "raw_output": "SELECT \n    p.[PlaylistId],\n    p.[Name],\n    COUNT(DISTINCT t.[GenreId]) AS GenreCount,\n    COUNT(DISTINCT a.[ArtistId]) AS ArtistCount\nFROM \n    [Playlist] p\nJOIN \n    [PlaylistTrack] pt ON p.[PlaylistId] = pt.[PlaylistId]\nJOIN \n    [Track] t ON pt.[TrackId] = t.[TrackId]\nJOIN \n    [Album] a ON t.[AlbumId] = a.[AlbumId]\nGROUP BY \n    p.[PlaylistId], p.[Name]",
      "execution_success": true,
      "exact_match": false,
      "fuzzy_match": false,
      "row_count_match": false,
      "row_overlap_pct": 0.0,
      "result_match": false,
      "failure_mode": "wrong_row_count",
      "gt_row_count": 12,
      "gen_row_count": 14,
      "missing_count": 12,
      "extra_count": 14,
      "latency_s": 1.93
    }
  ]
}